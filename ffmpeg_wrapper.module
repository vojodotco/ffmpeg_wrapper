<?php

/* $Id$ */

// This implements a wrapper for FFmpeg so that we don't have to reinvent the 
// the wheel everytime we want to do soemthing with video, audio, or images


/* ************************************************ */
/* DRUPAL HOOKS */
/* ************************************************ */

/**
 * Implementation of hook_menu().
 * @param boolean $may_cache
 * @return array of menu items
 */
function ffmpeg_wrapper_menu($may_cache) {
  $items = array();
  if ($may_cache) { 
    $items[] = array(
      'path' => 'admin/settings/ffmpeg_wrapper',
      'title' => t('FFmpeg Wrapper'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('ffmpeg_wrapper_admin'),
      'access' => user_access('administer ffmpeg wrapper'),
    );
  }
  return $items;
}


/**
 * implementation of hook_perm()
 */
function ffmpeg_wrapper_perm() {
  return array('administer ffmpeg wrapper');
}


/**
 * builds the admin form
 * @return drupal form array
 */
function ffmpeg_wrapper_admin() {

  $form['ffmpeg_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t('FFmpeg'),
  );

  $form['ffmpeg_wrapper']['mm_ffmpeg_about'] = array(
    '#type' => 'fieldset',
    '#title' => t('About FFmpeg installation'),
    '#collapsible' => true,
    '#collapsed' => true,
  );
  
  $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_version'] = array(
    '#type' => 'item',
    '#title' => t('FFmpeg version'),
    '#value' =>  '<blockquote>'. ffmpeg_wrapper_run_command(' -v') .'</blockquote>',
    '#description' => t('Version of FFmpeg running on your system'),
  ); 
  
  $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_formats'] = array(
    '#type' => 'item',
    '#title' => t('Supported file formats'),
    '#value' =>  ffmpeg_wrapper_formats_data_display(),
    '#description' => t('File formats that the installed version of FFmpeg supports.'),
  ); 
  
  $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_codecs'] = array(
    '#type' => 'item',
    '#title' => t('Installed codecs'),
    '#value' => ffmpeg_wrapper_get_codecs_display(),
    '#description' => t('FFmpeg was either compiled with these codecs, or these are the codecs available on your system'),
  ); 

  $form['ffmpeg_wrapper']['ffmpeg_wrapper_path'] = array(
    '#type' => 'textfield',
    '#title' => t('FFmpeg path'),
    '#default_value' => variable_get('ffmpeg_wrapper_path', '/usr/bin/ffmpeg'),
    '#description' => t("Absolute path to the FFmpeg exeutable."),
  );

  return system_settings_form($form);
}

/* ************************************************ */
/* FFmpeg Wrapper Functions  */
/* ************************************************ */


/**
 * gets data from ffmpeg
 * @param $options are the options to run ffmpeg with
 * @param boolean $error_check runs error checking on the output
 * @return output of the command
 */
function ffmpeg_wrapper_run_command($options, $error_check = true) {
 $command = variable_get('ffmpeg_wrapper_path', '/opt/ffmpeg/current/bin/ffmpeg') .' '. $options; 

 ob_start();
   passthru($command ." 2>&1", $command_return);
   $command_output = ob_get_contents();
 ob_end_clean();
 
 // do error handling if requested
 if ($error_check) {
   if (! ffmpeg_wrapper_error_check($command_output, $command, true)){
     return false;
   }
 }

 return $command_output; 
}



/**
 * checks an incoming file path extension to
 * see if it can be decoded 
 * @param $file is a full system filepath
 * @return true if file is in the list of decodeable files
 */
function ffmpeg_wrapper_can_decode($path){
  $file_types = ffmpeg_wrapper_get_file_formats('decode');  
  $path_parts = pathinfo($path);
  
  // exception handling  
  // WMVs are sometimes asf files
  if ($path_parts['extension'] == 'wmv') {$exception = 'asf';}
  
  if ($file_types) { 
    foreach ($file_types as $file_type) {
      if ($path_parts['extension']) {
        if (stristr($file_type, $path_parts['extension']) || stristr($file_type, $exception) ) {
          return true;
        } 
      }
    }
  }
  return false;  
}


/**
 * gets an array of codec types usable on this system
 * this should probably be smoothed out so that it doesn't rely on
 * text so much
 * @ TODO this needs to be rethought to pass params right
 * @param string $ret determins hand back of encode/decode
 * @return is array of codecs or specific encode/decode options
 */
function ffmpeg_wrapper_get_codecs($ret = null) { 
  
  // get formats from ffmpeg
  $output = ffmpeg_wrapper_run_command('-formats');
 
  // parse the list 
  // we know where the codecs are by looking at the output of ffmpeg -formats
  $codecs_formats_pos = strpos($output, "Codecs:");
  $codecs_formats_pos_end = strpos($output, "Supported file protocols:");  
  $codecs = substr($output, $codecs_formats_pos, ($codecs_formats_pos_end - $codecs_formats_pos));  
  // remove the extra text
  $codecs = str_replace('Codecs:', '', $codecs);
  // convert to array
  $codecs = explode("\n", $codecs);

  foreach ($codecs as $codec) {
   
    // match the decode, encode, type, S|D|T options (see: http://lists.mplayerhq.hu/pipermail/ffmpeg-user/2006-January/002003.html) 
    // name
    $pattern ='/[ ]*([D ])([E ])([ VA])([S ])([ D])([ T])[ ]*([a-zA-Z0-9_,]*)[ ]*([a-zA-Z0-9,_ ]*)/';
    preg_match($pattern, $codec, $matches);

    // codec names
    $a_format['name'] = $matches[7];
    
    // get the codec type
    if ($matches[3] == 'A') {
      $a_format['type'] = t('audio');
      $encode_formats[] = $a_format['name'];
    }
    else {
      $a_format['type'] = t('video');
    }
    
    // get the decode value
    if ($matches[1] == 'D') {
      $a_format['decode'] = t('yes');
      $decode_formats[] = $a_format['name'];
    }
    else {
      $a_format['decode'] = t('no');       
    }
   
    // get the encode value
    if ($matches[2] == 'E') {
      $a_format['encode'] = t('yes');
      $encode_formats[] = $a_format['name'];
    }
    else {
      $a_format['encode'] = t('no');          
    }
   
    if ($a_format['name']) {     
      $rows[] = $a_format;
    }
    $a_format = null;    
  }  
  
  switch ($ret) {
    case 'encode':
      return $encode_formats;
    break;
    case 'decode':
      return $decode_formats;
    break;
    default:
      return $rows;
    break;
  } 
}


/**
 * gets an array of format types usable on this system
 * this should probably be smoothed out so that it doesn't rely on
 * text so much
 * @param string $ret determins what to hand back (encode/decode)
 * @return array of options
 */
function ffmpeg_wrapper_get_file_formats($ret = null) { 
  static $rows, $encode_formats, $decode_formats;
 
  // only parse if this hasn't been set 
  if (! is_array($rows)) {
    $formats =  ffmpeg_wrapper_run_command('-formats');

    // slice up the format output
    $startpos = strpos($formats, 'File formats:');
    $endpos = strpos($formats, 'Codecs:');
    $formats = substr($formats, $startpos, $endpos - $startpos);
    
    //remove the header
    $formats = str_replace('File formats:', '', $formats);
    
    $formats = explode("\n", $formats);
 
    $decode_formats = array();
    $encode_formats = array();

    foreach ($formats as $format) {
      
      // match the decode, encode, format, description
      $pattern ='/[ ]*([D ])([E ])[ ]*([a-zA-Z0-9_,]*)[ ]*([a-zA-Z0-9,_ ]*)/';
      preg_match($pattern, $format, $matches);
      
      $a_format['type'] = $matches[3];
      $a_format['name'] = $matches[4];
        
      if ($matches[1] == 'D') {
        $a_format['decode'] = t('yes');
        $decode_formats[] = $a_format['type'];
      }
      else {
        $a_format['decode'] = t('no');       
      }
       
      if ($matches[2] == 'E') {
        $a_format['encode'] = t('yes');
        $encode_formats[] = $a_format['type'];
      }
      else {
        $a_format['encode'] = t('no');          
      }
       
      $a_format['description'] = $matches[4];
      if ($a_format['description']) {
        $rows[] = $a_format;
      }       
      
    }  
  }

  switch ($ret) {
    case 'encode':
      return $encode_formats;
    break;
    case 'decode':
      return $decode_formats;
    break;
    default:
      return $rows;
    break;
  }
}


/**
 * this gets the duration of a video
 * @param string $path is the path to file
 * @param boolean $timecode return time code or seconds
 * @return int is the duration in seconds or timecode as string
 */
function ffmpeg_wrapper_file_duration($path, $timecode) {
  // get duration from ffmpeg
  $output =  ffmpeg_wrapper_run_command("-i $path");

  // parse the output looking for "Duration: 00:02:12"
  $pattern = "/Duration: (.*[0-9:])(\.*[0-9]), start/";
  preg_match($pattern, $output, $matches);

  $time = $matches[1];
  
  if (! $timecode) { 
    // now we need to convert the time code to seconds
    // get the time into an array
    $time = explode(':', $time);
    
    if ($time[1] != '00') {
      $seconds = $seconds + ($time[0] * 60);
    }
    if ($time[2] != '00') {
      $seconds = $seconds + ($time[1] * (60*60));
    }
    $seconds = $seconds + $time[2];
    
    $time = $seconds;
  }

  return $time;
}


/**
 * checks to make sure that FFmpeg is in the path
 * @return boolean
 */
function ffmpeg_wrapper_executable(){
  if (! ffmpeg_wrapper_run_command('')) {
    return false;     
  }
  return true;
}


/**
 * displays a table of the supported ffmpeg file formats
 */
function ffmpeg_wrapper_formats_data_display() {
  $header = array(t('name'), t('type'), t('decode'), t('encode'), t('description') );
  $output = theme('table', $header, ffmpeg_wrapper_get_file_formats() );
  return $output;
}


/**
 * displays a table of the ffmpeg encoding and decoding options
 */
function ffmpeg_wrapper_get_codecs_display() {
  $header = array(t('codec'), t('codec type'), t('decode'), t('encode'));
  $output = theme('table', $header, ffmpeg_wrapper_get_codecs() );
  return $output;
}


/**
 * checks ffmpeg's output for errors and tries to handle them some way
 * @param $output is the output from a shell command
 * @param $command is the command run
 * @param $watchdog is boolean, log errors to drupal's watchdog
 * @return true if no errors, false if errors
 * 
 **/
function ffmpeg_wrapper_error_check($output, $command, $watchdog = true) {

  // build the error conditions
  // these are all pulled by hand at this point
  $errors = array(
    '/Segmentation fault/i',
    '/Unsupported/i',
    '/Unknown format/i', // bad format
    '/Unable for find a suitable output format for/i',
    '/Incorrect frame size/i',
    '/Unsupported codec/i',
    '/Could not write header/i',
    '/sh: [0-9a-zA-Z\/]*: not found/i',
  );

  // check for error conditions    
  foreach ($errors as $error) {
  	preg_match($error, $output, $matches);
    if ($matches[0]) {
      ffmpeg_wrapper_error_log($command, $matches[0], $watchdog);
      return false;
    }
  }
  return true;
}


/**
 * takes error conditions from the conversion process and deals
 * with them according to the admin configuration
 * 
 * @param string $output is the command line output
 * @param string $error is the problem being reported
 * @param boolean $watchdog should we log this?
 */
function ffmpeg_wrapper_error_log($command, $error, $watchdog){
  // create an error log
  $message = t('FFmpeg failed to convert a file. FFmpeg said: @error Command was: ffmpeg @command', array('@error' => $error, '@command' => $command));  
  if ($watchdog) {
    watchdog('FFmpeg', $message, 'WATCHDOG_ERROR');
  }
}