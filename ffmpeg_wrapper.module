<?php

/* $Id$ */

// This implements a wrapper for FFmpeg so that we don't have to reinvent the
// the wheel every time we want to do something with video, audio, or images


/* ************************************************ */
/* DRUPAL HOOKS */
/* ************************************************ */

/**
 * Implementation of hook_menu().
 */
function ffmpeg_wrapper_menu() {
  $items = array();
  $items['admin/settings/ffmpeg_wrapper'] = array(
    'title' => 'FFmpeg Wrapper',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ffmpeg_wrapper_admin'),
    'access arguments' => array('administer ffmpeg wrapper'),
  );
  $items[] = array(
    'path' => 'admin/settings/ffmpeg_wrapper/default',
    'title' => 'FFmpeg Wrapper',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  return $items;
}


/**
 * Implementation of hook_perm().
 */
function ffmpeg_wrapper_perm() {
  return array('administer ffmpeg wrapper');
}


/* ************************************************ */
/* FFmpeg Wrapper Admin Functions                   */
/* ************************************************ */

/**
 * Build the admin form.
 */
function ffmpeg_wrapper_admin() {
  // always clear caches when if settings are updated
  cache_clear_all('ffmpeg_wrapper_codecs', 'cache');
  cache_clear_all('ffmpeg_wrapper_output_formats', 'cache');
  cache_clear_all('ffmpeg_wrapper_file_formats', 'cache');

  $form['ffmpeg_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t('FFmpeg'),
  );

  $form['ffmpeg_wrapper']['ffmpeg_wrapper_path'] = array(
    '#type' => 'textfield',
    '#title' => t('FFmpeg path'),
    '#default_value' => variable_get('ffmpeg_wrapper_path', '/usr/bin/ffmpeg'),
    '#description' => t('Absolute path to the FFmpeg exeutable. Leave blank if you do not need this.'),
  );

  $form['ffmpeg_wrapper']['ffmpeg_wrapper_vhook'] = array(
    '#type' => 'textfield',
    '#title' => t('Path to the FFmpeg vhook libraries'),
    '#default_value' => variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook'),
    '#description' => t('Absolute path to the FFmpeg vhook directory. No trailing slash. Leave blank if you do not need this'),
  );

  // configuration options
  // only display if we can reach the binary
  if (ffmpeg_wrapper_run_command()) {
    $form['ffmpeg_wrapper']['ffmpeg_wrapper_about'] = array(
      '#type' => 'fieldset',
      '#title' => t('About FFmpeg installation'),
      '#collapsible' => true,
      '#collapsed' => true,
    );

    $form['ffmpeg_wrapper']['ffmpeg_wrapper_about']['ffmpeg_wrapper_version'] = array(
      '#type' => 'item',
      '#title' => t('FFmpeg version'),
      '#value' =>  '<blockquote>'. ffmpeg_wrapper_run_command('-v') .'</blockquote>',
      '#description' => t('Version of FFmpeg running on your system'),
    );

    $form['ffmpeg_wrapper']['ffmpeg_wrapper_about']['ffmpeg_wrapper_formats'] = array(
      '#type' => 'item',
      '#title' => t('Supported file formats'),
      '#value' =>  ffmpeg_wrapper_formats_data_display(),
      '#description' => t('File formats that the installed version of FFmpeg supports.'),
    );

    $form['ffmpeg_wrapper']['ffmpeg_wrapper_about']['ffmpeg_wrapper_codecs'] = array(
      '#type' => 'item',
      '#title' => t('Installed codecs'),
      '#value' => ffmpeg_wrapper_get_codecs_display(),
      '#description' => t('FFmpeg was either compiled with these codecs, or these are the codecs available on your system'),
    );
  }

  // get a list of the vhooks in the system
  if (ffmpeg_wrapper_vhook_list()) {
    $form['ffmpeg_wrapper']['ffmpeg_wrapper_vhooks'] = array(
      '#type' => 'fieldset',
      '#title' => t('vhook files installed on this system'),
      '#collapsible' => true,
      '#collapsed' => true,
    );
    $form['ffmpeg_wrapper']['ffmpeg_wrapper_vhooks']['ffmpeg_wrapper_vhook'] = array(
      '#type' => 'item',
      '#title' => t('vhook files'),
      '#value' =>  implode('<br />', ffmpeg_wrapper_vhook_list()),
      '#description' => t('List of all the Vhook files found.'),
    );
  }
  return system_settings_form($form);
}


/**
 * validate the options on the ffmpeg form
 *
 * @param int $form_id
 * @param array $form_values
 */
function ffmpeg_wrapper_admin_validate($form, &$form_state) {
  // make sure we've got the path to the ffmpeg binary
  if (! ffmpeg_wrapper_run_command(null, false, $form_state['values']['ffmpeg_wrapper_path']) && $form_values['ffmpeg_wrapper_path']) {
    form_set_error('ffmpeg_wrapper_path', t('FFmpeg binary was not found on the path you specified. Maybe try a different path?'));
  }

  // check and see if we can find the vhook directory
  if (! is_dir($form_state['values']['ffmpeg_wrapper_vhook']) && $form_state['values']['ffmpeg_wrapper_vhook']) {
    form_set_error('ffmpeg_wrapper_vhook', t('The vhook directory was not found on the path you specified. Maybe try a different path?'));
  }
}


/* ************************************************ */
/* Interactions with ffmpeg                         */
/* ************************************************ */

/**
 * Get data from ffmpeg.
 *
 * @param $command
 *   The options to run ffmpeg with.
 * @param $error_check
 *   If TRUE, runs error checking on the output.
 * @param $path
 *   Overrides the system settings.
 * @param $ffmpeg_object
 *   Object for passing debug and other kinds of data through the system.
 * @return
 *   Output of the command.
 */
function ffmpeg_wrapper_run_command($command = '', $error_check = true, $path = '', &$ffmpeg_object = null) {
  // override the system path?
  if (! $path) {
    $path = variable_get('ffmpeg_wrapper_path', '/usr/bin/ffmpeg');
  }
  if (empty($ffmpeg_object)) {
    $ffmpeg_object = new stdClass();
  }

  // Create some exceptions for dealing with pipes and semicolons
  $pattern = array('\;', '\|');
  $replace = array(';', '|');

  // Escape our command, but make sure that we allow | and ;
  $ffmpeg_object->command = str_replace($pattern, $replace, escapeshellcmd($path .' '. $command));

  $ffmpeg_object->cwd = getcwd();

  // does binary exist?
  if (! file_exists($path)) {
    return false;
  }

  $descriptor_spec = array(
     0 => array('pipe', 'r'),
     1 => array('pipe', 'w'),
     2 => array('pipe', 'w')
  );

  $pipes = array();
  $process = proc_open($ffmpeg_object->command, $descriptor_spec, $pipes, null, null, array('binary_pipes' => true));
  if (is_resource($process)) {
    fclose($pipes[0]);
    $ffmpeg_object->output = stream_get_contents($pipes[1]);
    fclose($pipes[1]);
    $ffmpeg_object->output .= stream_get_contents($pipes[2]);
    fclose($pipes[2]);
    $command_return = proc_close($process);
  }


  // Find the output file in the command if there was one.
  // This is sort of hacky but is helpful for passing the file out.
  preg_match("/.*'(.*)'$/i", $command, $matches);
  $ffmpeg_object->output_file = !empty($matches[1]) ? $matches[1] : null;

  // do error handling if requested
  if ($error_check) {
    if (! ffmpeg_wrapper_error_check($ffmpeg_object, true)){
      return false;
    }
  }
  return $ffmpeg_object->output;
}


/**
 * builds a list of the ffmpeg vhook options installed on this machine
 * @TODO we need to get more information on how the vhook system works and how
 *       admins can utilize it
 *
 * @param string $path
 * @return array
 */
function ffmpeg_wrapper_vhook_list($path = '') {
  static $files;

  // if we have a list already
  if ($files) {
     return $files;
  }

  // build the path
  if (! $path) {
    $path = variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook');
  }

  // @TODO replace below with file_scan_directory($path);

  // check to see if the directory is correct
  if (is_dir($path)) {
    // open the directory
    if ($dir = opendir($path)) {
      while (($file = readdir($dir)) !== false) {
        // do not this or parrent directory
        if ($file != "." && $file != "..") {
          $files[] = $path .'/'. $file;
        }
      }
      closedir($dir);
    }
    if (count($files)) {
      return $files;
    }
  }
}


/**
 * Check an incoming file to see if it can be decoded by comparing the file's codec
 * and format against the list of decode formats in FFMPEG.
 *
 * @param $file
 *   string, A full system filepath.
 * @param $types
 *   array, what kind of decode do we need to check for
 * @return
 *   boolean, TRUE if file is in the list of decodeable files.
 */
function ffmpeg_wrapper_can_decode($path, $types = array('video', 'audio')) {
  // get the kind of files
  $file_types = ffmpeg_wrapper_get_file_formats('decode');

  // get the format and codec information on this file
  $file_data = ffmpeg_wrapper_file_data($path);

   // if the file has multiple formats, all formats
   // must be in $file_types Otherwise, it is
   // not supported by ffmpeg.
  foreach(explode(',', $file_data['format']) as $type) {
    if (! in_array($type, $file_types)) {
      return false;
    }
  }

  // if we have na values for the audio and video codecs, the file can not be decoded
  // @ TODO is this really true? The logic below does not seem to indicate this,
  //        however, I might not understand what the 'na' value really means
  if ($file_data['audio']['codec'] == 'na' && $file_data['video']['codec'] == 'na') {
    return false;
  }

  // Now get installed codecs to compare file codecs
  foreach (ffmpeg_wrapper_get_codecs('decode') as $codec) {
    if ($codec == $file_data['audio']['codec'] || $file_data['audio']['codec'] == 'na' ) {
       // are we only handing back audio?
      if ($types['audio'] && ! $types['video']) { return true; }
      $can_audio_decode = true;
    }

    if ($codec == $file_data['video']['codec'] || $file_data['video']['codec'] == 'na') {
      // are we only handing back video?
      if ($types['video'] && ! $types['audio']) { return true; }
      $can_video_decode = true;
    }

    // If we can decode both audio and video, the file is ok
    if ($can_audio_decode && $can_video_decode) {
      return true;
    }
  }
  return false;
}


/**
 * Get an array of codec types usable on this system.
 * This should probably be smoothed out so that it doesn't rely on text so
 * much.
 * Caches data to avoid extra command line hits.
 *
 * @ TODO this needs to be rethought to pass params right
 *
 * @param $return
 *   Determins hand back of encode/decode.
 * @return
 *   Array of codecs or specific encode/decode options.
 */
function ffmpeg_wrapper_get_codecs($return = 'rows') {
  $cache_id = 'ffmpeg_wrapper_codecs';
  $cache = cache_get($cache_id, 'cache');
  if (!isset($cache->data)) {
    $data = array();
    // get formats from ffmpeg
    $output = ffmpeg_wrapper_run_command('-formats');

    // parse the list
    // we know where the codecs are by looking at the output of ffmpeg -formats
    $codecs_formats_pos = strpos($output, "Codecs:");
    $codecs_formats_pos_end = strpos($output, "Supported file protocols:");
    $codecs = substr($output, $codecs_formats_pos, ($codecs_formats_pos_end - $codecs_formats_pos));
    // remove the extra text
    $codecs = str_replace('Codecs:', '', $codecs);
    // convert to array
    $codecs = explode("\n", $codecs);

    $rows = array();
    foreach ($codecs as $codec) {
      // match the decode, encode, type, S|D|T options (see: http://lists.mplayerhq.hu/pipermail/ffmpeg-user/2006-January/002003.html)
      // name
      $pattern ='/[ ]*([D ])([E ])([ VA])([S ])([ D])([ T])[ ]*([a-zA-Z0-9_,]*)[ ]*([a-zA-Z0-9,_ ]*)/';
      preg_match($pattern, $codec, $matches);

      // codec names
      $a_format['name'] = $matches[7];

      // get the codec type
      if ($matches[3] == 'A') {
        $a_format['type'] = t('audio');
        $encode_formats[] = $a_format['name'];
      }
      else {
        $a_format['type'] = t('video');
      }

      // get the decode value
      if ($matches[1] == 'D') {
        $a_format['decode'] = t('yes');
        $decode_formats[] = $a_format['name'];
      }
      else {
        $a_format['decode'] = t('no');
      }

      // get the encode value
      if ($matches[2] == 'E') {
        $a_format['encode'] = t('yes');
        $encode_formats[] = $a_format['name'];
      }
      else {
        $a_format['encode'] = t('no');
      }

      if ($a_format['name']) {
        $rows[] = $a_format;
      }
      $a_format = null;
    }
    $data['encode'] = $encode_formats;
    $data['decode'] = $decode_formats;
    $data['rows'] = $rows;
    cache_set($cache_id, $data, 'cache', CACHE_TEMPORARY);
  }
  else {
    $data = $cache->data;
  }

  return $data[$return];
}


/**
 * Get a list of codecs in key value form- for use in form display
 *
 * @param $type
 *   audio or video.
 * @return
 *   Array of codec names.
 */
function ffmpeg_wrapper_return_codecs($type) {
  static $codecs;
  if (! empty($codecs[$type])) {
    return $codecs[$type];
  }
  $codecs = array();
  $codecs[$type] = array(0 => t('Use default'));
  // get list of avaiable audio and video codecs
  $codec_list = ffmpeg_wrapper_get_codecs();
  if ($codec_list) {
    foreach ($codec_list as $codec) {
      if ($codec['encode'] == "yes" && $codec['type'] == $type) {
        $codecs[$type][$codec['name']] = $codec['name'];
      }
    }
  }
  return $codecs[$type];
}


/**
 * Helper function to build the list of output formats on the system.
 * Data is cached to reduce hits to ffmpeg.
 *
 * @return
 *   Array of key values
 */
function ffmpeg_wrapper_output_formats() {
  $cache_id = 'ffmpeg_wrapper_output_formats';
  $cache = cache_get($cache_id, 'cache');
  if (!isset($cache->data)) {
    // get all the encoding options
    if (! $outputs = ffmpeg_wrapper_get_file_formats('encode')) {
    	watchdog('ffmpeg_wrapper', 'No output formats found. Path to ffmpeg is probably wrong', array(), WATCHDOG_ERROR);
    	return array();
    }
    // rebuild as a select array
    $formats = array(t('Select output type'));
    foreach ($outputs as $output) {
      $formats[$output] = $output;
    }
    cache_set($cache_id, $formats, 'cache', CACHE_TEMPORARY);
  }
  else {
    $formats = $cache->data;
  }
  return $formats;
}


/**
 * Build the output rates for each type of bit rate that ffmpeg offers.
 *
 * @param $type
 *   Type of bit rate: "ab", "ar", "fps" or "br".
 * @return
 *   Array of key values.
 */
function ffmpeg_wrapper_output_rates($type) {
  static $rates;
  if (! $rates) {
    $rates = array(
     'ab'  => array('16k' => '16k', '22k' => '22k', '32k' => '32k', '64k' => t('64k (default)'), '128k' => '128k', '192k' => '192k', '256k' => '256k'),
     'ar' => array('11025' => t('11khz'), '22050' => t('22khz'), '32000' => t('32khz'), '44100' => t('44.1khz (default)') ),
     'fps' => array(10 => 10, 15 => 15, 20 => 20, 25 => t('25 (default)'), 29.97 => 29.97),
     'br' => array('50k' => t('50kps'), '100k' => t('100kps'), '150k' => t('150kps'), '200k' => t('200kps'), '250k' => t('250kps (default)'), '300k' => t('300kps'), '500k' => t('500kps'), '750k' => t('750kps'), '1000k' => t('1000kps'), '1250k' => t('1250kps'), '1500k' => t('1500kps'), '2000k' => t('2000kps')),
    );
  }
  return $rates[$type];
}


/**
* Output dimentions form settings.
* @return
*   An array of frame sizes.
*/
function ffmpeg_wrapper_frame_sizes(){
  $frame_sizes = array(
    '0' => t('No alteration'),
    '128x96' => '128x96',
    '176x144' => '176x144',
    '320x240' => '320x240',
    '352x288' => '352x288',
    '512x386' => '512x386',
    '704x576' => '704x576'
  );
  $frame_sizes['other'] = t('Other');
  return $frame_sizes;
}


/**
 * Get an array of format types usable on this system.
 * This should probably be smoothed out so that it doesn't rely on text so
 * much. If no value for $ret is given, return the descriptions. This data
 * is all built by scanning the output from ffmpeg.
 *
 * @param $ret
 *   Determins what to hand back (encode/decode).
 * @return
 *   Array of options.
 */
function ffmpeg_wrapper_get_file_formats($ret = 'row') {
  $cache_id = 'ffmpeg_wrapper_file_formats';
  $cache = cache_get($cache_id, 'cache');
  // do we have cached data?
  if (!isset($cache->data)) {
    // if we can't get formats, do not bother
    if (! $formats = ffmpeg_wrapper_run_command('-formats') ) {
      return;
    }
    // slice up the format output
    $startpos = strpos($formats, 'File formats:');
    $endpos = strpos($formats, 'Codecs:');
    $formats = substr($formats, $startpos, $endpos - $startpos);
    //remove the header
    $formats = str_replace('File formats:', '', $formats);

    $decode_formats = array();
    $encode_formats = array();

    $rows = array();

    foreach (explode("\n", $formats) as $format) {
      // match the decode, encode, format, description
      $pattern ='/[ ]*([D ])([E ])[ ]*([a-zA-Z0-9_,]*)[ ]*([^\$]*)/';
      preg_match($pattern, $format, $matches);

      $a_format['type'] = $matches[3];
      $a_format['name'] = $matches[4];

      // check for decoding
      if ($matches[1] == 'D') {
        $a_format['decode'] = t('yes');
        // we can have multiple types per format
        $types = explode(',', $a_format['type']);
        foreach ($types as $type) {
          $decode_formats[] = $type;
        }
      }
      else {
        $a_format['decode'] = t('no');
      }

      // check for encoding
      if ($matches[2] == 'E') {
        $a_format['encode'] = t('yes');
        // we can have multiple types per format
        $types = explode(',', $a_format['type']);
        foreach ($types as $type) {
          $encode_formats[] = $type;
        }
      }
      else {
        $a_format['encode'] = t('no');
      }

      $a_format['description'] = $matches[4];
      if ($a_format['description']) {
        $rows[] = $a_format;
      }
    }

    $output = array();
    $output['encode'] = $encode_formats;
    $output['decode'] = $decode_formats;
    $output['row'] = $rows;

    cache_set($cache_id, $output, 'cache', CACHE_TEMPORARY);
  }
  else {
    $output = $cache->data;
  }
  // return the requested data
  return $output[$ret];
}


/**
 * Get the duration of a video.
 *
 * @param $path
 *   The path to file.
 * @param $timecode
 *   If TRUE, return time code, otherwise return seconds.
 * @param $output
 *   string, output of ffmpeg if it has already been run
 * @return
 *   Duration in seconds as an integer or timecode as string.
 */
function ffmpeg_wrapper_file_duration($path, $timecode = null, $output = null) {
  // do we have any output from ffmpeg already?
  if (! $output) {
    // get duration from ffmpeg
    // need quotes around the path parameter in case filename has spaces.
    $output = ffmpeg_wrapper_run_command("-i \"$path\"");
  }

  // parse the output looking for "Duration: 00:02:12"
  $pattern = "/Duration: ([0-9]+:[0-9]+:[0-9]+)\.[0-9]+/";
  preg_match($pattern, $output, $matches);

  $time = $matches[1];

  if (! $timecode) {
    // now we need to convert the time code to seconds
    // get the time into an array
    $time = explode(':', $time);

    $seconds = 0;
    if ($time[0] != '00') {
      $seconds += $time[0] * 60 * 60;
    }
    if ($time[1] != '00') {
      $seconds += $time[1] * 60;
    }
    $seconds += $time[2];
    $time = $seconds;
  }
  return $time;
}


/**
 * This function produces file data from an incoming file
 * @param $path
 * @param $timecode
 * @return array
 */
function ffmpeg_wrapper_file_data($path = null) {
  if (file_exists($path)) {
    // get duration from ffmpeg
    // need quotes around the path parameter in case filename has spaces.
    $output = ffmpeg_wrapper_run_command("-i \"$path\"");

    // get file format
    $pattern = '/Input #0, (.*),/';
    preg_match($pattern, $output, $matches);
    $file['format'] = !empty($matches[1]) ? $matches[1] : 'na';

    // get file duration
    $file['duration'] = ffmpeg_wrapper_file_duration(null, null, $output);

    // get bit rate
    $pattern = "/bitrate: ([0-9].*\/s)/";
    preg_match($pattern, $output, $matches);
    $file['bitrate'] = !empty($matches[1]) ? $matches[1] : 'na';

    // get audio settings
    // format is: codec, sample rate, stereo/mono, bitrate
    $pattern = "/Audio: (.*), ([0-9]*) Hz, (stereo|mono)/";
    preg_match($pattern, $output, $matches);
    $file['audio']['codec'] = !empty($matches[1]) ? $matches[1] : 'na';
    $file['audio']['ar'] = !empty($matches[2]) ? $matches[2] : 'na';
    $file['audio']['ac'] = (!empty($matches[3]) && $matches[3] == 'stereo') ? 2 : 1;

    // take the last match and extract the bit rate if present
    $pattern = "/Audio: .* (.*) kb\/s/";
    preg_match($pattern, $output, $matches);
    $file['audio']['ab'] = !empty($matches[1]) ? $matches[1] : 'na';

    // VIDEO ----------------------------------------
    // The formating of video can be difficult. We use 3 different
    // patterns to look for the video information

    // try pattern that takes into account a codec's color space (example: yuv420p)
    // eg: Video: mpeg1video, yuv420p, 320x240 [PAR 1:1 DAR 4:3], 990 kb/s, 30.00 tb(r)
    // the above is: codec, color space, frame size, bitrate, frame rate
    $pattern1 = "/Video: ([^,]+), ([^,]+), ([0-9x]+)[^,]*, ([0-9]*.*\/s|[A-Za-z]+[^,]*), ([0-9\.]*)/";

    // pattern that omits video bitrate but not color space.
    // eg: Video: mpeg4, yuv420p, 640x480 [PAR 1:1 DAR 4:3], 23.98 tb(r)
    // the above is: codec, color space, frame size, frame rate
    $pattern2 = "/Video: ([^,]+), ([^0-9][^,]*), ([0-9x]+)[^,]*, ([0-9\.]*)/";

    // pattern that omits a codec's color space and video bitrate
    // eg: Video: mpeg4, 640x480, 29.97 tb(r)
    // the above is: codec, frame size, frame rate
    $pattern3 = "/Video: ([^,]+), ([0-9x]+)[^,]*, ([0-9\.]*)/";

    // did we find the video information on the first try ?
    if (preg_match($pattern1, $output, $matches)) {
      $file['video']['codec'] = !empty($matches[1]) ? $matches[1] : 'na';
      // $file['video']['type'] = $matches[2];
      $file['video']['s'] = !empty($matches[3]) ? $matches[3] : 'na';
      $file['video']['br'] = !empty($matches[4]) ? $matches[4] : 'na';
    }
    elseif (preg_match($pattern2, $output, $matches)) {
      $file['video']['codec'] = !empty($matches[1]) ? $matches[1] : 'na';
      $file['video']['s'] = !empty($matches[3]) ? $matches[3] : 'na';
      $file['video']['br'] = 'na';
    }
    elseif (preg_match($pattern3, $output, $matches)) {
      $file['video']['codec'] = !empty($matches[1]) ? $matches[1] : 'na';
      $file['video']['s'] = !empty($matches[3]) ? $matches[3] : 'na';
      $file['video']['br'] = 'na';
    }
    return $file;
  }
}


/**
 * Calculate an output size and a padding value for a video file.
 *
 * @param $file
 *   Path to the file to be converted.
 * @param $size
 *   The maximum dimensions of the output file, expressed as XXXxYYY. This will
 *   be cropped to match the original file's proportions and the remaining
 *   space will be used to calculate the padding.
 * @param $return
 *   Either 'padding' or 'size'.
 * @return
 *   Depending on the value of $return, the function returns either the size
 *   expressed as XXXxYYY, or the actual padding argument for FFmpeg, ie.
 *   "-padtop XX -padbottom XX". The result is statically cached, so you can
 *   call it multiple times without permormance issues.
 */
function ffmpeg_wrapper_padded_size($file, $size, $return = 'padding') {
  static $file_proportions;

  // Cache file proportions statically.
  if (!isset($file_proportions)) {
    $file_proportions = array();
  }
  if (isset($file_proportions[$file])) {
    return ($return == 'size') ? $file_proportions[$file][0] : $file_proportions[$file][1];
  }

  else {
    $pad = '';

    // Determine source file's dimensions and proportions.
    $info = ffmpeg_wrapper_file_data($file);
    if ($info && isset($info['video'])) {
      list($orig_x, $orig_y) = explode('x', $info['video']['s']);
      $orig_q = $orig_x / $orig_y;

      // Determine output dimensions and proportions.
      list($dest_x, $dest_y) = explode('x', $size);
      $dest_q = $dest_x / $dest_y;

      // Calculate new output size and padding.
      if ($orig_q > $dest_q) {
        // Width is the determining factor.
        $dest_y_calc = round($dest_x / $orig_q);
        // Make sure height is divisible by 2, otherwise ffmpeg freaks out.
        $dest_y_calc &= ~1;
        $size = $dest_x . 'x' . $dest_y_calc;
        $padding = $dest_y - $dest_y_calc;
        $padoptions = '-padtop %d -padbottom %d';
      }
      elseif ($dest_q > $orig_q) {
        // Height is the determining factor.
        $dest_x_calc = round($dest_y * $orig_q);
        // Make sure width is divisible by 2, otherwise ffmpeg freaks out.
        $dest_x_calc &= ~1;
        $size = $dest_x_calc . 'x' . $dest_y;
        $padding = $dest_x - $dest_x_calc;
        $padoptions = '-padleft %d -padright %d';
      }

      // Calculate padding on each side. Each value has to be a multiple of 2.
      $padding &= ~1;
      $padding1 = floor($padding / 2);
      $padding1 &= ~1;
      $padding2 = $padding - $padding1;
      $pad = sprintf($padoptions, $padding1, $padding2);
    }

    // Save and return the results.
    $file_proportions[$file] = array($size, $pad);
    return ($return == 'size') ? $size : $pad;
  }
}


/**
 * Check to make sure that FFmpeg is in the path.
 *
 * @return
 *   TRUE if FFmpeg can be executed, FALSE otherwise.
 */
function ffmpeg_wrapper_executable() {
  if (! ffmpeg_wrapper_run_command('')) {
    return false;
  }
  return true;
}


/**
 * Display a table of the supported ffmpeg file formats.
 *
 * @return
 *   The themed HTML form.
 */
function ffmpeg_wrapper_formats_data_display() {
  $header = array(t('name'), t('type'), t('decode'), t('encode'), t('description') );
  $output = theme('table', $header, ffmpeg_wrapper_get_file_formats() );
  return $output;
}


/**
 * Display a table of the ffmpeg encoding and decoding options.
 *
 * @return
 *   The themed HTML form.
 */
function ffmpeg_wrapper_get_codecs_display() {
  $header = array(t('codec'), t('codec type'), t('decode'), t('encode'));
  $output = theme('table', $header, ffmpeg_wrapper_get_codecs() );
  return $output;
}


/**
 * Check FFmpeg's output for errors and try to handle them some way.
 *
 * @param $ffmpeg_object
 *   Object containing all the data to check errors against
 *   - shell output and command run.
 * @param boolean $watchdog
 *   If TRUE, log errors to Drupal's watchdog.
 * @return
 *   TRUE if no errors, FALSE if errors.
 *
 **/
function ffmpeg_wrapper_error_check(&$ffmpeg_object, $watchdog = true) {
  $return = true;

  // build the error conditions these are all pulled by hand at this point
  // @NOTE one has to be careful to have a specific match as there are strings
  // in the output from #ffmpeg which containg "error"
  $errors = array(
    '/Segmentation fault .*/i',
    '/Unsupported .*/i',
    // match: bad formats
    '/Unknown format .*/i',
    '/Unable for find a suitable output format for .*/i',
    '/Incorrect frame size .*/i',
    '/Unsupported codec .*/i',
    '/Could not write header .*/i',
    '/already exists. Overwrite/i',
    '/sh: [0-9a-zA-Z\/]*: not found .*/i',
    '/no such file or directory .*/i',
    '/.*does not support that sample rate.*/i',
    // match: Error while opening codec for output stream #0.1 - maybe incorrect parameters such as bit_rate, rate, width or height
    '/Error while opening codec for output stream.*/i',
    // match: I/O error occured
    '/I\/O error occured/i',
    '/Failed to add video hook function*/i',
    '/ffmpeg: unrecognized option*/i',
    '/Could not open */i',
  );

  // check for error conditions
  foreach ($errors as $error) {
    preg_match($error, $ffmpeg_object->output, $matches);
    if (count($matches)) {
      $ffmpeg_object->errors[] = print_r($matches[0], true);
      if ($watchdog) {
        $message = 'FFmpeg failed to convert a file. <b>FFmpeg said:</b> !error <br /><b>Command was:</b> ffmpeg !command <br /><b>Output was:</b> <pre>!output</pre>';
        $variables = array('!error' => $matches[0], '!command' => $ffmpeg_object->command, '!output' => $ffmpeg_object->output);
        watchdog('FFmpeg Wrapper', $message, $variables, WATCHDOG_ERROR);
      }
      return false;
    }
  }

  // check to see that a viable file was created
  if (!empty($ffmpeg_object->output_file)) {
    // check to see that the file had data
    if (filesize($ffmpeg_object->output_file) < 10 ) {
      $message = t('FFmpeg created a file, but it does not have any data');
      $ffmpeg_object->errors[] = $message;
      if ($watchdog) {
        watchdog('FFmpeg', $message,  array(), WATCHDOG_ERROR);
      }
      $return = false;
    }
  }

  return $return;
}


/**
 * Create a path to the called vhook library.
 *
 * @param $name
 *   The name of the vhook library.
 * @return
 *   A full path.
 */
function ffmpeg_wrapper_path_to_vhook($name) {
  $path = variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook/') . $name;
  if (file_exists($path)) {
    return $path;
  }
}

/* ************************************************** */
/* handle requests for configurations                 */
/* ************************************************** */

/**
 * Take an output format and return an array of configuration options.
 * This is a hand built list. Will return default options below to preserve
 * form integrity while switching things.
 *
 * @param $output
 *   An output type (eg: flv, avi, mp4, etc).
 * @return
 *   Array of configuration options.
 */
function ffmpeg_wrapper_output_rules($output) {
  // check to see if we have a configuration for this
  $path = drupal_get_path('module', 'ffmpeg_wrapper');
  if (file_exists($path .'/conf/'. $output .'.conf')) {
    require_once($path .'/conf/'. $output .'.conf');
    return $configuration;
  }

  // we don't have a configuration setting, load up the defaults
  // for any thing that we don't have data for. First check
  // and see if we have a cache
  $cache = cache_get('ffmpeg_wrapper_default_output');
  if (is_array($cache->data)) {
    return $cache->data;
  }

  // no cache, build out the default options
  $default['audio'] = array(
    'ab' => ffmpeg_wrapper_output_rates('ab'),
    'ar' => ffmpeg_wrapper_output_rates('ar'),
    'acodec' => ffmpeg_wrapper_return_codecs('audio'),
  );
  $default['video'] = array(
    'fps' => ffmpeg_wrapper_output_rates('fps'),
    'br' =>  ffmpeg_wrapper_output_rates('br'),
    'vcodec' => ffmpeg_wrapper_return_codecs('video'),
  );
  $default['default'] = 'default';
  cache_set('ffmpeg_wrapper_default_output', $default, 'cache', CACHE_TEMPORARY);
  return $default;
}

/**
 * Display the output rules as json.
 *
 * @param $output
 *   An output type (eg: flv, avi, mp4, etc).
 */
function ffmpeg_wrapper_output_display($output) {
  // get the output rules for this
  if ($rules = ffmpeg_wrapper_output_rules($output)) {
    // now build the JSON out
    print(drupal_to_js($rules));
  }
  exit();
}