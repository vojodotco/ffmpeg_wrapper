<?php

/* $Id$ */

// This implements a wrapper for FFmpeg so that we don't have to reinvent the 
// the wheel everytime we want to do soemthing with video, audio, or images


/* ************************************************ */
/* DRUPAL HOOKS */
/* ************************************************ */

/**
 * Implementation of hook_menu().
 */
function ffmpeg_wrapper_menu($may_cache) {
  $items = array();
  if ($may_cache) { 
    $items[] = array(
      'path' => 'admin/settings/ffmpeg_wrapper',
      'title' => t('FFmpeg Wrapper settings'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('ffmpeg_wrapper_admin'),
      'access' => user_access('administer ffmpeg wrapper'),
    );
    // hand back the specific configurations for a codec
    $items[] = array(
      'path' => 'ffmpeg_wrapper/output',
      'title' => t('FFmpeg Wrapper'),
      'callback' => 'ffmpeg_wrapper_output_display',    
      'access' => user_access('access content'),
    );    
  }
  return $items;
}


/**
 * Implementation of hook_perm().
 */
function ffmpeg_wrapper_perm() {
  return array('administer ffmpeg wrapper');
}


/**
 * Build the admin form.
 */
function ffmpeg_wrapper_admin() {

  $form['ffmpeg_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t('FFmpeg'),
  );

  $form['ffmpeg_wrapper']['ffmpeg_wrapper_path'] = array(
    '#type' => 'textfield',
    '#title' => t('FFmpeg path'),
    '#default_value' => variable_get('ffmpeg_wrapper_path', '/usr/bin/ffmpeg'),
    '#description' => t('Absolute path to the FFmpeg exeutable. Leave blank if you do not need this.'),
  );

  $form['ffmpeg_wrapper']['ffmpeg_wrapper_vhook'] = array(
    '#type' => 'textfield',
    '#title' => t('Path to the FFmpeg vhook libraries'),
    '#default_value' => variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook'),
    '#description' => t('Absolute path to the FFmpeg vhook directory. No trailing slash. Leave blank if you do not need this'),
  );
  
  // configuration options
  // only display if we can reach the binary 
  if (ffmpeg_wrapper_run_command('')) {
    $form['ffmpeg_wrapper']['mm_ffmpeg_about'] = array(
      '#type' => 'fieldset',
      '#title' => t('About FFmpeg installation'),
      '#collapsible' => true,
      '#collapsed' => true,
    );
    
    $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_version'] = array(
      '#type' => 'item',
      '#title' => t('FFmpeg version'),
      '#value' =>  '<blockquote>'. ffmpeg_wrapper_run_command(' -v') .'</blockquote>',
      '#description' => t('Version of FFmpeg running on your system'),
    ); 
    
    $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_formats'] = array(
      '#type' => 'item',
      '#title' => t('Supported file formats'),
      '#value' =>  ffmpeg_wrapper_formats_data_display(),
      '#description' => t('File formats that the installed version of FFmpeg supports.'),
    ); 
    
    $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_codecs'] = array(
      '#type' => 'item',
      '#title' => t('Installed codecs'),
      '#value' => ffmpeg_wrapper_get_codecs_display(),
      '#description' => t('FFmpeg was either compiled with these codecs, or these are the codecs available on your system'),
    ); 
  }
  
  // get a list of the vhooks in the system
  if (ffmpeg_wrapper_vhook_list()) {
    $form['ffmpeg_wrapper']['mm_ffmpeg_vhooks'] = array(
      '#type' => 'fieldset',
      '#title' => t('vhook files installed on this system'),
      '#collapsible' => true,
      '#collapsed' => true,
    );
    $form['ffmpeg_wrapper']['mm_ffmpeg_vhooks']['mm_ffmpeg_vhook'] = array(
      '#type' => 'item',
      '#title' => t('vhook files'),
      '#value' =>  implode('<br />', ffmpeg_wrapper_vhook_list()),
      '#description' => t('List of all the Vhook files found.'),
    ); 
  }
  return system_settings_form($form);
}


/**
 * validate the options on the ffmpeg form
 *
 * @param int $form_id
 * @param array $form_values
 */
function ffmpeg_wrapper_admin_validate($form_id, $form_values) {
  // make sure we've got the path to the ffmpeg binary
  if (! ffmpeg_wrapper_run_command(null, false, $form_values['ffmpeg_wrapper_path']) && $form_values['ffmpeg_wrapper_path']) {
    form_set_error('ffmpeg_wrapper_path', t('FFmpeg binary was not found on the path you specified. Maybe try a different path?'));
  }
  
  // check and see if we can find the vhook directory
  if (! is_dir($form_values['ffmpeg_wrapper_vhook']) && $form_values['ffmpeg_wrapper_vhook']) {
    form_set_error('ffmpeg_wrapper_vhook', t('The vhook directory was not found on the path you specified. Maybe try a different path?'));
  }
}


/* ************************************************ */
/* FFmpeg Wrapper Functions  */
/* ************************************************ */

/**
 * gets data from ffmpeg
 * @param string $options are the options to run ffmpeg with
 * @param boolean $error_check runs error checking on the output
 * @param string $path overrides the system settings
 * @return output of the command
 */
function ffmpeg_wrapper_run_command($options, $error_check = true, $path) {
  if (! $path) {
    $path = variable_get('ffmpeg_wrapper_path', '/usr/bin/ffmpeg');
  }
  
  $command =  $path .' '. $options; 
  
  // does binary exist?
  if (! file_exists($path)) {
    return false;
  }
 
  ob_start();
    passthru($command ." 2>&1", $command_return);
    $command_output = ob_get_contents();
  ob_end_clean();
 
  // do error handling if requested
  if ($error_check) {
    if (! ffmpeg_wrapper_error_check($command_output, $command, true)){
      return false;
    }
  }

  ob_start();
    passthru($command ." 2>&1", $command_return);
    $command_output = ob_get_contents();
  ob_end_clean();
 
  // do error handling if requested
  if ($error_check) {
    if (! ffmpeg_wrapper_error_check($command_output, $command, true)){
      return false;
    }
  }

  return $command_output; 
}


/**
 * builds a list of the ffmpeg vhook options installed on this machine
 *
 * @param string $path
 * @return array
 */
function ffmpeg_wrapper_vhook_list($path) {
  static $files;
  
  // if we have a list already
  if ($files) { 
     return $files;
  }
  
  // build the path
  if (! $path) {
    $path = variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook');    
  }
  
  // check to see if the directory is correct
  if (is_dir($path)) {
    // open the directory
    if ($dir = opendir($path)) {
      while (($file = readdir($dir)) !== false) {
        // do not this or parrent directory
        if ($file != "." && $file != "..") { 
          $files[] = $path .'/'. $file;        
        }
      }
      closedir($dir);
    }
    if (count($files)) {
      return $files;
    }   
  }
}



/**
 * Check an incoming file path extension to see if it can be decoded.
 * 
 * @param $file
 *   A full system filepath.
 * @return
 *   TRUE if file is in the list of decodeable files.
 */
function ffmpeg_wrapper_can_decode($path) {
  $file_types = ffmpeg_wrapper_get_file_formats('decode');  
  $path_parts = pathinfo($path);
  
  // exception handling  
  // WMVs are sometimes asf files
  if (preg_match('/wmv/i', $path_parts['extension'])) {
    $exception = 'asf';
  }
  
  if ($file_types) { 
    foreach ($file_types as $file_type) {
      if ($path_parts['extension']) {
        if (stristr($file_type, $path_parts['extension']) || stristr($file_type, $exception) ) {
          return true;
        } 
      }
    }
  }
  return false;  
}


/**
 * Get an array of codec types usable on this system.
 * This should probably be smoothed out so that it doesn't rely on text so
 * much.
 * @ TODO this needs to be rethought to pass params right
 * 
 * @param $ret
 *   Determins hand back of encode/decode.
 * @return
 *   Array of codecs or specific encode/decode options.
 */
function ffmpeg_wrapper_get_codecs($ret = null) { 
  
  // get formats from ffmpeg
  $output = ffmpeg_wrapper_run_command('-formats');
 
  // parse the list 
  // we know where the codecs are by looking at the output of ffmpeg -formats
  $codecs_formats_pos = strpos($output, "Codecs:");
  $codecs_formats_pos_end = strpos($output, "Supported file protocols:");  
  $codecs = substr($output, $codecs_formats_pos, ($codecs_formats_pos_end - $codecs_formats_pos));  
  // remove the extra text
  $codecs = str_replace('Codecs:', '', $codecs);
  // convert to array
  $codecs = explode("\n", $codecs);

  foreach ($codecs as $codec) {
   
    // match the decode, encode, type, S|D|T options (see: http://lists.mplayerhq.hu/pipermail/ffmpeg-user/2006-January/002003.html) 
    // name
    $pattern ='/[ ]*([D ])([E ])([ VA])([S ])([ D])([ T])[ ]*([a-zA-Z0-9_,]*)[ ]*([a-zA-Z0-9,_ ]*)/';
    preg_match($pattern, $codec, $matches);

    // codec names
    $a_format['name'] = $matches[7];
    
    // get the codec type
    if ($matches[3] == 'A') {
      $a_format['type'] = t('audio');
      $encode_formats[] = $a_format['name'];
    }
    else {
      $a_format['type'] = t('video');
    }
    
    // get the decode value
    if ($matches[1] == 'D') {
      $a_format['decode'] = t('yes');
      $decode_formats[] = $a_format['name'];
    }
    else {
      $a_format['decode'] = t('no');       
    }
   
    // get the encode value
    if ($matches[2] == 'E') {
      $a_format['encode'] = t('yes');
      $encode_formats[] = $a_format['name'];
    }
    else {
      $a_format['encode'] = t('no');          
    }
   
    if ($a_format['name']) {     
      $rows[] = $a_format;
    }
    $a_format = null;    
  }  
  
  switch ($ret) {
    case 'encode':
      return $encode_formats;
    break;
    case 'decode':
      return $decode_formats;
    break;
    default:
      return $rows;
    break;
  } 
}


/**
 * Get a list of codecs in key value form.
 * 
 * @param $type
 *   Audio or video.
 * @return 
 *   Array of codec names.
 */
function ffmpeg_wrapper_return_codecs($type) {
  static $codecs;
  if (! empty($codecs[$type])) {
    return $codecs[$type];
  }
  // get list of avaiable audio and video codecs
  $codec_list = ffmpeg_wrapper_get_codecs();
  $acodecs = array();
  $vcodecs = array();
  if ($codec_list) {
    foreach ($codec_list as $codec) {
      if ($codec['encode'] == "yes" && $codec['type'] == $type) { 
        $codecs[$type][$codec['name']] = $codec['name'];
      }
    }
  }
  return $codecs[$type];
}


/**
 * Helper function to build the list of output formats on the system.
 *
 * @return
 *   Array of key values
 */
function ffmpeg_wrapper_output_formats() {
	static $formats;
	if (! $formats) {
		// get all the encoding options		
    $outputs = ffmpeg_wrapper_get_file_formats('encode');
    // rebuild as a select array
    $formats[0] = t('Please select');
    foreach ($outputs as $output) {
      $formats[$output] = $output;      
    }
	}
  return $formats;
}

/**
 * builds the output rates for each type of bit rate that 
 * ffmpeg offers
 *
 * @param string $type
 * @return array of key values
 */
function ffmpeg_wrapper_output_rates($type) {
	static $rates;	
	if (! $rates) {
		$rates = array (		
	   'ab'  => array(8 => 8, 16 => 16, 32 => 32, 64 => t('64k (default)'), 128 => 128, 192 => 192, 256 => 256),
	   'ar' => array('11025' => t('11khz'), '22050' => t('22khz'), '32000' => t('32khz'), '44100' => t('44.1khz (default)') ),
     'fps' => array(10 =>10, 15 => 15, 20 => 20, 25 => t('25 (default)'), 29.97 => 29.97),
     'br' => array('50k' => t('50kps'), '100k' => t('100kps'), '150k' => t('150kps'), '200k' => t('200kps'), '250k' => t('250kps'), '300k' => t('300kps'), '500k' => t('500kps'), '750k' => t('750kps'), '1000k' => t('1000kps'), '1250k' => t('1250kps'), '1500k' => t('1500kps'), '2000k' => t('2000kps')),
 		);
	}	
	return $rates[$type];	
}

/**
* Output dimentions form settings.
* @return
*   An array of frame sizes.
*/
function ffmpeg_wrapper_frame_sizes(){
  $frame_sizes = drupal_map_assoc(array('128x96', '176x144', '320x240', '352x288', '512x386', '704x576'));
  $frame_sizes['other'] = t('Other');
  return $frame_sizes;
}


/**
 * Get an array of format types usable on this system.
 * This should probably be smoothed out so that it doesn't rely on text so
 * much.
 * 
 * @param $ret
 *   Determins what to hand back (encode/decode).
 * @return
 *   Array of options.
 */
function ffmpeg_wrapper_get_file_formats($ret = null) { 
  static $rows, $encode_formats, $decode_formats;
 
  // only parse if this hasn't been set 
  if (! is_array($rows)) {
    $formats =  ffmpeg_wrapper_run_command('-formats');

    // slice up the format output
    $startpos = strpos($formats, 'File formats:');
    $endpos = strpos($formats, 'Codecs:');
    $formats = substr($formats, $startpos, $endpos - $startpos);
    
    //remove the header
    $formats = str_replace('File formats:', '', $formats);
    
    $formats = explode("\n", $formats);
 
    $decode_formats = array();
    $encode_formats = array();

    foreach ($formats as $format) {
      
      // match the decode, encode, format, description
      $pattern ='/[ ]*([D ])([E ])[ ]*([a-zA-Z0-9_,]*)[ ]*([a-zA-Z0-9,_ ]*)/';
      preg_match($pattern, $format, $matches);
      
      $a_format['type'] = $matches[3];
      $a_format['name'] = $matches[4];
        
      if ($matches[1] == 'D') {
        $a_format['decode'] = t('yes');
        $decode_formats[] = $a_format['type'];
      }
      else {
        $a_format['decode'] = t('no');       
      }
       
      if ($matches[2] == 'E') {
        $a_format['encode'] = t('yes');
        $encode_formats[] = $a_format['type'];
      }
      else {
        $a_format['encode'] = t('no');          
      }
       
      $a_format['description'] = $matches[4];
      if ($a_format['description']) {
        $rows[] = $a_format;
      }       
      
    }  
  }

  switch ($ret) {
    case 'encode':
      return $encode_formats;
    break;
    case 'decode':
      return $decode_formats;
    break;
    default:
      return $rows;
    break;
  }
}


/**
 * Get the duration of a video.
 * 
 * @param $path
 *   The path to file.
 * @param $timecode
 *   If TRUE, return time code, otherwise return seconds.
 * @return
 *   Duration in seconds as an integer or timecode as string.
 */
function ffmpeg_wrapper_file_duration($path, $timecode) {
  // get duration from ffmpeg
  $output = ffmpeg_wrapper_run_command("-i $path");

  // parse the output looking for "Duration: 00:02:12"
  $pattern = "/Duration: (.*[0-9:])(\.*[0-9]), start/";
  preg_match($pattern, $output, $matches);

  $time = $matches[1];
  
  if (! $timecode) { 
    // now we need to convert the time code to seconds
    // get the time into an array
    $time = explode(':', $time);
    
    if ($time[1] != '00') {
      $seconds = $seconds + ($time[0] * 60);
    }
    if ($time[2] != '00') {
      $seconds = $seconds + ($time[1] * (60*60));
    }
    $seconds = $seconds + $time[2];
    
    $time = $seconds;
  }

  return $time;
}


/**
 * Check to make sure that FFmpeg is in the path.
 * 
 * @return
 *   TRUE if FFmpeg can be executed, FALSE otherwise.
 */
function ffmpeg_wrapper_executable() {
  if (! ffmpeg_wrapper_run_command('')) {
    return false;     
  }
  return true;
}


/**
 * Display a table of the supported ffmpeg file formats.
 * 
 * @return
 *   The themed HTML form.
 */
function ffmpeg_wrapper_formats_data_display() {
  $header = array(t('name'), t('type'), t('decode'), t('encode'), t('description') );
  $output = theme('table', $header, ffmpeg_wrapper_get_file_formats() );
  return $output;
}


/**
 * Display a table of the ffmpeg encoding and decoding options.
 * 
 * @return
 *   The themed HTML form.
 */
function ffmpeg_wrapper_get_codecs_display() {
  $header = array(t('codec'), t('codec type'), t('decode'), t('encode'));
  $output = theme('table', $header, ffmpeg_wrapper_get_codecs() );
  return $output;
}


/**
 * Check FFmpeg's output for errors and try to handle them some way.
 * 
 * @param $output
 *   The output from a shell command.
 * @param $command
 *   The command run.
 * @param $watchdog
 *   If TRUE, log errors to Drupal's watchdog.
 * @return
 *   TRUE if no errors, FALSE if errors.
 * 
 **/
function ffmpeg_wrapper_error_check($output, $command, $watchdog = true) {

  // build the error conditions
  // these are all pulled by hand at this point
  $errors = array(
    '/Segmentation fault/i',
    '/Unsupported/i',
    '/Unknown format/i', // bad format
    '/Unable for find a suitable output format for/i',
    '/Incorrect frame size/i',
    '/Unsupported codec/i',
    '/Could not write header/i',
    '/sh: [0-9a-zA-Z\/]*: not found/i',
  );

  // check for error conditions    
  foreach ($errors as $error) {
  	preg_match($error, $output, $matches);
    if ($matches[0]) {
      ffmpeg_wrapper_error_log($command, $matches[0], $watchdog);
      return false;
    }
  }
  return true;
}


/**
 * Take error conditions from the conversion process and deal
 * with them according to the admin configuration.
 * 
 * @param $output
 *   The command line output.
 * @param $error
 *   The problem being reported.
 * @param $watchdog
 *   If TRUE, log errors to Drupal's watchdog.
 */
function ffmpeg_wrapper_error_log($command, $error, $watchdog) {
  // create an error log
  $message = t('FFmpeg failed to convert a file. FFmpeg said: @error Command was: ffmpeg @command', array('@error' => $error, '@command' => $command));  
  if ($watchdog) {
    watchdog('FFmpeg', $message, 'WATCHDOG_ERROR');
  }
}


/**
 * Create a path to the called vhook library.
 * 
 * @param $name
 *   The name of the vhook library.
 * @return
 *   A full path.
 */
function ffmpeg_wrapper_path_to_vhook($name) {
	if ($path = file_exists(variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook/') . $name)) {
		return $path;
	}	
}

/* ************************************************** */
/* handle requests for configurations                 */
/* ************************************************** */

/**
 * takes an output format, returns an array of configuration
 * options. This is a hand built list. Will return default options
 * below to preserver form integrity while switching things
 * @param string $output
 *   this is an output type (eg: flv, avi, mp4, etc)
 * @return string
 */ 
function ffmpeg_wrapper_output_rules($output) {
	// check to see if we have a configuration for this
	$path = drupal_get_path('module', 'ffmpeg_wrapper');
	if (file_exists($path .'/conf/'. $output .'.conf')) {
		require_once($path .'/conf/'. $output .'.conf');
		return $configuration;
	}

	// we don't have a configuration setting, load up the defaults
	// for any thing that we don't have data for. First check 
	// and see if we have a cache
	//$cache = cache_get('ffmpeg_wrapper_default_output', 'cache');
	if (unserialize($cache->data)) {
	  return unserialize($cache->data);
	}
	
	// no cache, build out the default options
	$default['audio'] = array(
	  'ab' => ffmpeg_wrapper_output_rates('ab'),
	  'ar' => ffmpeg_wrapper_output_rates('ar'),
	  'acodec' => ffmpeg_wrapper_return_codecs('audio'),
	);
	$default['video'] = array(
	  'fps' => ffmpeg_wrapper_output_rates('fps'),
	  'br' =>  ffmpeg_wrapper_output_rates('br'),
	  'vcodec' => ffmpeg_wrapper_return_codecs('video'),
	);
	$default['default'] = 'default';
	
	cache_set('ffmpeg_wrapper_default_output', 'cache', serialize($default), CACHE_TEMPORARY);
	
	return $default;	
}

/**
 * Display the output rules as json.
 * 
 * @param $output
 *   An output type (eg: flv, avi, mp4, etc).
 */
function ffmpeg_wrapper_output_display($output) {
  // get the output rules for this 
  if ($rules = ffmpeg_wrapper_output_rules($output)) {
    // now build the JSON out
    print(drupal_to_js($rules));
  }
  exit();
}


/**
 * Load the js. This is a wrapper function just so other modules can use this.
 * 
 * @param $prefix
 *   The standard prefix to the elements that will be modified.
 * @param $bind_element
 *   The name of the element (minus the prefix) that will be modifed.
 */
function ffmpeg_wrapper_enable($prefix, $bind_element = '') {
  // because of the way drupal handles form element ids, we have to transform
  // underscores in string to dashes
  $bind_element = str_replace('_', '-', $bind_element);
  $prefix = str_replace('_', '-', $prefix);
  
  drupal_add_js('
    $(document).ready(function () {
      $(\'#'. $prefix . $bind_element .'\').bind("change", function () {ffmpeg_wrapper_update_options("'. $prefix .'", "'. $bind_element .'"); });
    });',  
    'inline');
	drupal_add_js(array('ffmpeg_wrapper' => array(
	  'ffmpeg_wrapper_output_url' => url('ffmpeg_wrapper/output/'),
	  'default_string' => t('default'),
	  )), 'setting');
	drupal_add_js(drupal_get_path('module', 'ffmpeg_wrapper') .'/ffmpeg_wrapper.js');
}


/* ************************************************** */
/* ffmpeg_wrapper forms                               */
/* ************************************************** */

/**
 * Build a generic form for any module to implementm ffmpeg configuration.
 * This will give any module the ajax form configuration updates. 
 * Validation and submission need to be handled by the calling module - this 
 * only builds the form call this form inside your form function.
 *
 * @param $configuration
 *   An array of configuration data - could be $form_values.
 * @param $prefix
 *   A prefix for the form elelements, needed for javascript activation on
 *   complex forms (eg: media mover).
 * @return array 
 *   A Drupal form array.
 */
function ffmpeg_wrapper_configuration_form($configuration, $form_prefix = '' ) {
	        
  // enable the javascript configuration options on the output type to use AJAX
  // to update the allowed values
  ffmpeg_wrapper_enable($form_prefix, 'ffmpeg_output_type');
    
  $form['ffmpeg_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t("FFmpeg video conversion settings"),
    '#collapsed' => false,
  );
    
  // build the output formats
  $form['ffmpeg_wrapper']['ffmpeg_output_type'] = array(
    '#type' => 'select',
    '#title' => t('Output format'),
    '#options' => ffmpeg_wrapper_output_formats(),
    '#default_value' => $configuration['ffmpeg_output_type'],
    '#description' => t('Select the output format. Note, some formats may require setting audio or video codecs.'),   
  );
  
  // ---------------------------------------------
  // Audio options
  $form['ffmpeg_wrapper']['audio'] = array(
    '#type' => 'fieldset',
    '#title' => t('Audio conversion settings'),
    '#collapsed' => $configuration['ffmpeg_audio_advanced'] ? false : true,
    '#collapsible' => true,
  );
  $form['ffmpeg_wrapper']['audio']['ffmpeg_audio_advanced'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use advanced settings'),
    '#description' => t('Use the advanced audio encoding options. If this is off, FFmpeg will encode at a rate similar to the source material.'),
    '#default_value' => $configuration['ffmpeg_audio_advanced'],
  );  
  $form['ffmpeg_wrapper']['audio']["ffmpeg_audio_ab"] = array(
    '#type' => 'select',
    '#title' => t('Audio bit rate'),
    '#options' => ffmpeg_wrapper_output_rates('ab'),
    '#default_value' => $configuration['ffmpeg_audio_ab'] ? $configuration['ffmpeg_audio_ab'] :  64,
    '#description' => t("Audio bit rate for conversion file."),
  );
  $form['ffmpeg_wrapper']['audio']["ffmpeg_audio_ar"] = array(
    '#type' => 'select',
    '#title' => t('Audio sample rate'),
    '#options' => ffmpeg_wrapper_output_rates('ar'),
    '#default_value' => $configuration['ffmpeg_audio_ar'] ? $configuration['ffmpeg_audio_ar'] : 44100,
    '#description' => t('Audio sample rate for conversion.'),
  );  
  // set the audio codec in use
  $form['ffmpeg_wrapper']['audio']["ffmpeg_audio_acodec"] = array(
    '#type' => 'select',
    '#title' => t('Audio codec'),
    '#options' => ffmpeg_wrapper_return_codecs('audio'),
    '#default_value' => $configuration['ffmpeg_audio_acodec'] ? $configuration['ffmpeg_audio_acodec'] : null ,
    '#description' => t('Select the codec for the output format. Please note, you may need to pick an appropriate video codec for the transcoding. WARNING the codec support right now is experimental. Things may not work as expected.'),   
  );
  
  // -------------------------------------------
  // Video options
  $form['ffmpeg_wrapper']['video'] = array(
    '#type' => 'fieldset',
    '#title' => t('Video conversion settings'),
    '#collapsed' => $configuration['ffmpeg_video_advanced'] ? false : true,
    '#collapsible' => true,
  );
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_advanced'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use advanced settings'),
    '#description' => t('Use the advanced video encoding options. If this is off, FFmpeg will encode flv at 200 kb/s, 128x96, 25fps.'),
    '#default_value' => $configuration['ffmpeg_video_advanced'],
  );    
  // video frame size
  $frame_size = ffmpeg_wrapper_frame_sizes();
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_size'] = array(
    '#type' => 'select',
    '#title' => t('Video frame size'),
    '#options' => $frame_size,
    '#default_value' => $configuration['ffmpeg_video_size'],
    '#description' => t('Dimensions of the converted video. Use the <em>Other</em> option to define your custom size.'),
    '#attributes' => array('class' => 'ffmpeg-video-size'),
    '#validate' => array('mm_ffmpeg_config_video_size_validate' => array('ffmpeg_video_size')),
  );
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_size_other'] = array(
    '#type' => 'textfield',
    '#title' => t('Video frame (Other) size'),
    '#default_value' => $configuration['ffmpeg_video_size_other'],
    '#description' => t('Dimensions of the converted video, of the format 600x400.'),
    '#prefix' => '<div class="ffmpeg-video-size-other">',
    '#suffix' => '</div>',
    '#validate' => array('mm_ffmpeg_config_video_size_validate' => array('ffmpeg_video_size_other')),
    '#size' => 12,
  );
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_fps'] = array(
    '#type' => 'select',
    '#title' => t('Video fps rate'),
    '#options' => ffmpeg_wrapper_output_rates('fps'),
    '#default_value' => $configuration['ffmpeg_video_fps'] ? $configuration['ffmpeg_video_fps'] : 25,
    '#description' => t("Sets the frames per second of the converted video."),
  );    
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_br'] = array(
    '#type' => 'select',
    '#title' => t('Video bit rate'),
    '#options' => ffmpeg_wrapper_output_rates('br'),
    '#default_value' => $configuration['ffmpeg_video_br'],
    '#description' => t('Target the output video to this bit rate.'),
  );    
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_vcodec'] = array(
    '#type' => 'select',
    '#title' => t('Video codec'),
    '#options' => ffmpeg_wrapper_return_codecs('video'),
    '#default_value' => $configuration['ffmpeg_video_vcodec'],
    '#description' => t('Select the codec for the output format. Please note, you may need to pick an appropriate audio codec for the transcoding.'),   
  );  
    
  $form['ffmpeg_wrapper']['time'] = array(
    '#type' => 'fieldset',
    '#title' => t('Video duration'),
    '#collapsed' => $configuration['ffmpeg_time_advanced'] ? false : true,
    '#collapsible' => true,
  );
  $form['ffmpeg_wrapper']['time']['ffmpeg_time_advanced'] = array(
    '#type' => 'checkbox',
    '#title' => t('Truncate the output video'),
    '#description' => t('Use this to limit the length of the output video. Useful for making a video teaser'),
    '#default_value' => $configuration['ffmpeg_time_advanced'],
  );
  $times = array(30 => "30 seconds", 60 => "1 minute", 120 => "2 minutes", 300 => "5 minutes");
  $form['ffmpeg_wrapper']['time']["ffmpeg_time"] = array(
    '#type' => 'select',
    '#title' => t('Video length'),
    '#options' => $times,
    '#default_value' => $configuration['ffmpeg_time'],
    '#description' => t("Set the max video length time."),
  );
  
  // FFmpeg custom command
  $form['ffmpeg_wrapper']['custom'] = array(
    '#type' => 'fieldset',
    '#title' => t('Custom FFmpeg command'),
    '#collapsed' => $configuration['ffmpeg_video_custom'] ? false : true,
    '#collapsible' => true,
  );
  $form['ffmpeg_wrapper']['custom']["ffmpeg_video_custom"] = array(
    '#type' => 'checkbox',
    '#title' => t('Use custom FFmpeg command'),
    '#description' => t('Use the custom FFmpeg command in the textfield below.'),
    '#default_value' => $configuration['ffmpeg_video_custom'],
  );
  $form['ffmpeg_wrapper']['custom']["ffmpeg_video_custom_command"] = array(
    '#type' => 'textfield',
    '#title' => t('Custom FFmpeg command'),
    '#description' => t('You can craft your own FFmpeg command. Please see the FFmpeg documentation for correct syntax. The command will replace <em>%in_file</em> and <em>%out_file</em> with the generated files. Please note, you can not use | or > in your commands.'),
    '#default_value' => $configuration['ffmpeg_video_custom_command'] ? $configuration['ffmpeg_video_custom_command'] : '-i %in_file %out_file',
  );
    
  // Watermarking options
  // only display if we have access to the watermarking files
  if (ffmpeg_wrapper_path_to_vhook('watermark.so')) {    
    $form['ffmpeg_wrapper']['watermark'] = array(
      '#type' => 'fieldset',
      '#title' => t('Video watermark settings'),
      '#collapsed' => $configuration['ffmpeg_video_wm'] ? false : true,
      '#collapsible' => true,
    );
    $form['ffmpeg_wrapper']['watermark']['ffmpeg_video_wm'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use watermark'),
      '#description' => t('Use a file to watermark the converted video.'),
      '#default_value' => $configuration['ffmpeg_video_wm'],
    );
    // @ TODO make this a file upload
    $form['ffmpeg_wrapper']['watermark']['ffmpeg_video_wm_file'] = array(
      '#type' => 'textfield',
      '#title' => t('Path to file'),
      '#description' => t('Absolute path to the watermark file.'),
      '#default_value' => $configuration['ffmpeg_video_wm_file'],
    );
  }

  // file chmod settings, maybe legacy..... 
  $form['ffmpeg_wrapper']['file'] = array(
    '#type' => 'fieldset',
    '#title' => t('File settings'),
    '#collapsed' => true,
    '#collapsible' => true,
  );
  $form['ffmpeg_wrapper']['file']["ffmpeg_output_perms"] = array(
    '#type' => 'textfield',
    '#title' => t('Output file permissions'),
    '#description' => t('Set the permissions on the output file. Default is 0644.'),
    '#default_value' => $configuration['ffmpeg_output_perms'] ? $configuration['ffmpeg_output_perms'] : '0644' ,
    '#size' => 4,
  );

  return $form;
}
