<?php

/* $Id$ */

// This implements a wrapper for FFmpeg so that we don't have to reinvent the 
// the wheel everytime we want to do soemthing with video, audio, or images


/* ************************************************ */
/* DRUPAL HOOKS */
/* ************************************************ */

/**
 * Implementation of hook_menu().
 * @param boolean $may_cache
 * @return array of menu items
 */
function ffmpeg_wrapper_menu($may_cache) {
  $items = array();
  if ($may_cache) { 
    $items[] = array(
      'path' => 'admin/settings/ffmpeg_wrapper',
      'title' => t('FFmpeg Wrapper'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('ffmpeg_wrapper_admin'),
      'access' => user_access('administer ffmpeg wrapper'),
    );
    // hand back the specific configurations for a codec
    $items[] = array(
      'path' => 'ffmpeg_wrapper/output',
      'title' => t('FFmpeg Wrapper'),
      'callback' => 'ffmpeg_wrapper_output_display',    
      'access' => user_access('access content'),
    );    
  }
  return $items;
}


/**
 * implementation of hook_perm()
 */
function ffmpeg_wrapper_perm() {
  return array('administer ffmpeg wrapper');
}


/**
 * builds the admin form
 * @return drupal form array
 */
function ffmpeg_wrapper_admin() {

  $form['ffmpeg_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t('FFmpeg'),
  );

  $form['ffmpeg_wrapper']['mm_ffmpeg_about'] = array(
    '#type' => 'fieldset',
    '#title' => t('About FFmpeg installation'),
    '#collapsible' => true,
    '#collapsed' => true,
  );
  
  $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_version'] = array(
    '#type' => 'item',
    '#title' => t('FFmpeg version'),
    '#value' =>  '<blockquote>'. ffmpeg_wrapper_run_command(' -v') .'</blockquote>',
    '#description' => t('Version of FFmpeg running on your system'),
  ); 
  
  $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_formats'] = array(
    '#type' => 'item',
    '#title' => t('Supported file formats'),
    '#value' =>  ffmpeg_wrapper_formats_data_display(),
    '#description' => t('File formats that the installed version of FFmpeg supports.'),
  ); 
  
  $form['ffmpeg_wrapper']['mm_ffmpeg_about']['mm_ffmpeg_codecs'] = array(
    '#type' => 'item',
    '#title' => t('Installed codecs'),
    '#value' => ffmpeg_wrapper_get_codecs_display(),
    '#description' => t('FFmpeg was either compiled with these codecs, or these are the codecs available on your system'),
  ); 

  $form['ffmpeg_wrapper']['ffmpeg_wrapper_path'] = array(
    '#type' => 'textfield',
    '#title' => t('FFmpeg path'),
    '#default_value' => variable_get('ffmpeg_wrapper_path', '/usr/bin/ffmpeg'),
    '#description' => t("Absolute path to the FFmpeg exeutable."),
  );

  $form['ffmpeg_wrapper']['ffmpeg_wrapper_vhook'] = array(
    '#type' => 'textfield',
    '#title' => t('Path to the FFmpeg vhook libraries'),
    '#default_value' => variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook/'),
    '#description' => t("Absolute path to the FFmpeg vhook libraries."),
  );
  
  
  return system_settings_form($form);
}

/* ************************************************ */
/* FFmpeg Wrapper Functions  */
/* ************************************************ */


/**
 * gets data from ffmpeg
 * @param $options are the options to run ffmpeg with
 * @param boolean $error_check runs error checking on the output
 * @return output of the command
 */
function ffmpeg_wrapper_run_command($options, $error_check = true) {
 $command = variable_get('ffmpeg_wrapper_path', '/opt/ffmpeg/current/bin/ffmpeg') .' '. $options; 

 ob_start();
   passthru($command ." 2>&1", $command_return);
   $command_output = ob_get_contents();
 ob_end_clean();
 
 // do error handling if requested
 if ($error_check) {
   if (! ffmpeg_wrapper_error_check($command_output, $command, true)){
     return false;
   }
 }

 return $command_output; 
}



/**
 * checks an incoming file path extension to
 * see if it can be decoded 
 * @param $file is a full system filepath
 * @return true if file is in the list of decodeable files
 */
function ffmpeg_wrapper_can_decode($path){
  $file_types = ffmpeg_wrapper_get_file_formats('decode');  
  $path_parts = pathinfo($path);
  
  // exception handling  
  // WMVs are sometimes asf files
  if (preg_match('/wmv/i', $path_parts['extension'])) {$exception = 'asf';}
  
  if ($file_types) { 
    foreach ($file_types as $file_type) {
      if ($path_parts['extension']) {
        if (stristr($file_type, $path_parts['extension']) || stristr($file_type, $exception) ) {
          return true;
        } 
      }
    }
  }
  return false;  
}


/**
 * gets an array of codec types usable on this system
 * this should probably be smoothed out so that it doesn't rely on
 * text so much
 * @ TODO this needs to be rethought to pass params right
 * @param string $ret determins hand back of encode/decode
 * @return is array of codecs or specific encode/decode options
 */
function ffmpeg_wrapper_get_codecs($ret = null) { 
  
  // get formats from ffmpeg
  $output = ffmpeg_wrapper_run_command('-formats');
 
  // parse the list 
  // we know where the codecs are by looking at the output of ffmpeg -formats
  $codecs_formats_pos = strpos($output, "Codecs:");
  $codecs_formats_pos_end = strpos($output, "Supported file protocols:");  
  $codecs = substr($output, $codecs_formats_pos, ($codecs_formats_pos_end - $codecs_formats_pos));  
  // remove the extra text
  $codecs = str_replace('Codecs:', '', $codecs);
  // convert to array
  $codecs = explode("\n", $codecs);

  foreach ($codecs as $codec) {
   
    // match the decode, encode, type, S|D|T options (see: http://lists.mplayerhq.hu/pipermail/ffmpeg-user/2006-January/002003.html) 
    // name
    $pattern ='/[ ]*([D ])([E ])([ VA])([S ])([ D])([ T])[ ]*([a-zA-Z0-9_,]*)[ ]*([a-zA-Z0-9,_ ]*)/';
    preg_match($pattern, $codec, $matches);

    // codec names
    $a_format['name'] = $matches[7];
    
    // get the codec type
    if ($matches[3] == 'A') {
      $a_format['type'] = t('audio');
      $encode_formats[] = $a_format['name'];
    }
    else {
      $a_format['type'] = t('video');
    }
    
    // get the decode value
    if ($matches[1] == 'D') {
      $a_format['decode'] = t('yes');
      $decode_formats[] = $a_format['name'];
    }
    else {
      $a_format['decode'] = t('no');       
    }
   
    // get the encode value
    if ($matches[2] == 'E') {
      $a_format['encode'] = t('yes');
      $encode_formats[] = $a_format['name'];
    }
    else {
      $a_format['encode'] = t('no');          
    }
   
    if ($a_format['name']) {     
      $rows[] = $a_format;
    }
    $a_format = null;    
  }  
  
  switch ($ret) {
    case 'encode':
      return $encode_formats;
    break;
    case 'decode':
      return $decode_formats;
    break;
    default:
      return $rows;
    break;
  } 
}


/**
 * returns a list of codecs in key value form
 * @param string $type audio or video
 * @return array 
 */
function ffmpeg_wrapper_return_codecs($type) {
  static $codecs;
  if ($codecs[$type]) {
    return $codecs[$type];
  }
  // get list of avaiable audio and video codecs
  $codec_list = ffmpeg_wrapper_get_codecs();
  $acodecs = array();
  $vcodecs = array();
  if ($codec_list) {
    foreach ($codec_list as $codec) {
      if ($codec['encode'] == "yes" && $codec['type'] == $type) { 
        $codecs[$type][$codec['name']] = $codec['name'];
      }
    }
  }
  return $codecs[$type];
}
    
    
/**
 * gets an array of format types usable on this system
 * this should probably be smoothed out so that it doesn't rely on
 * text so much
 * @param string $ret determins what to hand back (encode/decode)
 * @return array of options
 */
function ffmpeg_wrapper_get_file_formats($ret = null) { 
  static $rows, $encode_formats, $decode_formats;
 
  // only parse if this hasn't been set 
  if (! is_array($rows)) {
    $formats =  ffmpeg_wrapper_run_command('-formats');

    // slice up the format output
    $startpos = strpos($formats, 'File formats:');
    $endpos = strpos($formats, 'Codecs:');
    $formats = substr($formats, $startpos, $endpos - $startpos);
    
    //remove the header
    $formats = str_replace('File formats:', '', $formats);
    
    $formats = explode("\n", $formats);
 
    $decode_formats = array();
    $encode_formats = array();

    foreach ($formats as $format) {
      
      // match the decode, encode, format, description
      $pattern ='/[ ]*([D ])([E ])[ ]*([a-zA-Z0-9_,]*)[ ]*([a-zA-Z0-9,_ ]*)/';
      preg_match($pattern, $format, $matches);
      
      $a_format['type'] = $matches[3];
      $a_format['name'] = $matches[4];
        
      if ($matches[1] == 'D') {
        $a_format['decode'] = t('yes');
        $decode_formats[] = $a_format['type'];
      }
      else {
        $a_format['decode'] = t('no');       
      }
       
      if ($matches[2] == 'E') {
        $a_format['encode'] = t('yes');
        $encode_formats[] = $a_format['type'];
      }
      else {
        $a_format['encode'] = t('no');          
      }
       
      $a_format['description'] = $matches[4];
      if ($a_format['description']) {
        $rows[] = $a_format;
      }       
      
    }  
  }

  switch ($ret) {
    case 'encode':
      return $encode_formats;
    break;
    case 'decode':
      return $decode_formats;
    break;
    default:
      return $rows;
    break;
  }
}


/**
 * this gets the duration of a video
 * @param string $path is the path to file
 * @param boolean $timecode return time code or seconds
 * @return int is the duration in seconds or timecode as string
 */
function ffmpeg_wrapper_file_duration($path, $timecode) {
  // get duration from ffmpeg
  $output = ffmpeg_wrapper_run_command("-i $path");

  // parse the output looking for "Duration: 00:02:12"
  $pattern = "/Duration: (.*[0-9:])(\.*[0-9]), start/";
  preg_match($pattern, $output, $matches);

  $time = $matches[1];
  
  if (! $timecode) { 
    // now we need to convert the time code to seconds
    // get the time into an array
    $time = explode(':', $time);
    
    if ($time[1] != '00') {
      $seconds = $seconds + ($time[0] * 60);
    }
    if ($time[2] != '00') {
      $seconds = $seconds + ($time[1] * (60*60));
    }
    $seconds = $seconds + $time[2];
    
    $time = $seconds;
  }

  return $time;
}


/**
 * checks to make sure that FFmpeg is in the path
 * @return boolean
 */
function ffmpeg_wrapper_executable(){
  if (! ffmpeg_wrapper_run_command('')) {
    return false;     
  }
  return true;
}


/**
 * displays a table of the supported ffmpeg file formats
 */
function ffmpeg_wrapper_formats_data_display() {
  $header = array(t('name'), t('type'), t('decode'), t('encode'), t('description') );
  $output = theme('table', $header, ffmpeg_wrapper_get_file_formats() );
  return $output;
}


/**
 * displays a table of the ffmpeg encoding and decoding options
 */
function ffmpeg_wrapper_get_codecs_display() {
  $header = array(t('codec'), t('codec type'), t('decode'), t('encode'));
  $output = theme('table', $header, ffmpeg_wrapper_get_codecs() );
  return $output;
}


/**
 * checks ffmpeg's output for errors and tries to handle them some way
 * @param string $output 
 *   is the output from a shell command
 * @param string $command
 *   the command run
 * @param boolean $watchdog
 *   log errors to drupal's watchdog
 * @return boolean 
 *   true if no errors, false if errors
 * 
 **/
function ffmpeg_wrapper_error_check($output, $command, $watchdog = true) {

  // build the error conditions
  // these are all pulled by hand at this point
  $errors = array(
    '/Segmentation fault/i',
    '/Unsupported/i',
    '/Unknown format/i', // bad format
    '/Unable for find a suitable output format for/i',
    '/Incorrect frame size/i',
    '/Unsupported codec/i',
    '/Could not write header/i',
    '/sh: [0-9a-zA-Z\/]*: not found/i',
  );

  // check for error conditions    
  foreach ($errors as $error) {
  	preg_match($error, $output, $matches);
    if ($matches[0]) {
      ffmpeg_wrapper_error_log($command, $matches[0], $watchdog);
      return false;
    }
  }
  return true;
}


/**
 * takes error conditions from the conversion process and deals
 * with them according to the admin configuration
 * 
 * @param string $output 
 *   is the command line output
 * @param string $error 
 *   is the problem being reported
 * @param boolean $watchdog 
 *   should we log this?
 */
function ffmpeg_wrapper_error_log($command, $error, $watchdog){
  // create an error log
  $message = t('FFmpeg failed to convert a file. FFmpeg said: @error Command was: ffmpeg @command', array('@error' => $error, '@command' => $command));  
  if ($watchdog) {
    watchdog('FFmpeg', $message, 'WATCHDOG_ERROR');
  }
}


/**
 * creates a path to the called vhook library
 * @param string $name
 * @return full path
 */
function ffmpeg_wrapper_path_to_vhook($name) {
	if ($path = file_exists(variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook/') . $name)) {
		return $path;
	}	
}

/* ************************************************** */
/* handle requests for configurations                 */
/* ************************************************** */

/**
 * takes an output format, returns an array of configuration
 * options. This is a hand built list. Will return default options
 * below to preserver form integrity while switching things
 * @param string $output
 * @return string
 */ 
function ffmpeg_wrapper_output_rules($output) {
	// check to see if we have a configuration for this
	$path = drupal_get_path('module', 'ffmpeg_wrapper');
	if (file_exists($path .'/conf/'. $output .'.conf')) {
		require_once($path .'/conf/'. $output .'.conf');
		return $configuration;
	}

	// we don't have a configuration setting, load up the defaults
	// for any thing that we don't have data for. First check 
	// and see if we have a cache
	$cache = cache_get('ffmpeg_wrapper_default_output', 'cache');
	if (unserialize($cache->data)) {
	  return unserialize($cache->data);
	}
	
	// no cache, build out the default options
	$default['audio'] = array(
	  'ab' => array(8 => 8, 16 => 16, 32 => 32, 64 => t('64k (default)'), 128 => 128, 256 => 256),
	  'ar' => array('11025' => '11khz', '22050' => '22khz', '32000' => '34khz', '44100' => t('44.1khz (default)')),
	  'acodec' => ffmpeg_wrapper_return_codecs('audio'),
	);
	$default['video'] = array(
	  'fps' => array(0 => 'default', 10 =>10, 15 => 15, 20 => 20, 25 => t('25 (default)'), 29.97 => 29.97),
	  'br' =>  array('50k' => '50kps', '100k' => '100kps', '150k' => '150kps', '200k' => '200kps', '250k' => '250kps', '300k' => '300kps', '500k' => '500kps', '750k' => '750kps', '1000k' => '1000kps', '1250k' => '1250kps', '1500k' => '1500kps', '2000k' => '2000kps'),
	  'vcodec' => ffmpeg_wrapper_return_codecs('video'),
	);
	$default['default'] = 'default';
	
	cache_set('ffmpeg_wrapper_default_output', 'cache', serialize($default), CACHE_TEMPORARY);
	
	return $default;	
}


function ffmpeg_wrapper_output_display($output) {
  // get the output rules for this 
  if ($rules = ffmpeg_wrapper_output_rules($output)) {
    // now build the JSON out
    print(drupal_to_js($rules));
  	//print_r($rules);
  	exit();
  }
  exit();
}


/**
 * load the js. This is a wrapper function just so other
 * modules can use this
 * @param string $prefix is the standard prefix to the elements that will be modified
 * @param string $bind_element is the name of the element (minus the prefix) that will be modifed
 * @return javascript to head of page
 */
function ffmpeg_wrapper_enable($prefix, $bind_element) {
  // because of the way drupal handles form element ids, we have to transform
  // underscores in string to dashes
  $bind_element = str_replace('_', '-', $bind_element);
  $prefix = str_replace('_', '-', $prefix);
  
  drupal_add_js('
    $(document).ready(function () {
      $(\'#'. $prefix . $bind_element .'\').bind("change", function () {ffmpeg_wrapper_update_options("'. $prefix .'", "'. $bind_element .'"); });
    });',  
    'inline');
	drupal_add_js(array('ffmpeg_wrapper' => array('ffmpeg_wrapper_output_url' => url('ffmpeg_wrapper/output/'))), 'setting');
	drupal_add_js(drupal_get_path('module', 'ffmpeg_wrapper') .'/ffmpeg_wrapper.js');
}